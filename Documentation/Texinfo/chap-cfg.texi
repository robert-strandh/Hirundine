@node Nodes of a control-flow graph
@chapter Nodes of a control-flow graph

@section Data nodes

There are two kinds of data nodes in a @cfg{}; @emph{literals} and
@emph{registers}.  In figures illustrating some part of a @cfg{}, a
data node is drawn using an oval shape.  A literal can be the input of
one or more instructions, and it corresponds to a @commonlisp{}
object.  A register can be the input or the output of one or more
instructions.

@section Instruction nodes

An instruction node corresponds to some kind of action, typically
taking one or more inputs and generating one or more outputs.  An
instruction node can have @math{0}, @math{1}, or @math{2} successors,
depending on the type of the node.  Node types with @math{0}
successors correspond to instructions with some non-local control
transfer such as @code{return} or @code{unwind}.  An instruction node
can have any number of predecessors.  The order between the
predecessors is not significant.

In figures illustrating some parts of a @cfg{}, an instruction node is
drawn using a rectangular shape.

@subsection @code{parse-arguments-instruction}

@multitable {aaaa} {number of successors} {at least two}
@item @tab Number of inputs     @tab 0
@item @tab Number of outputs    @tab at least 2
@item @tab Number of successors @tab 1
@end multitable

A slot in an instruction of this type contains a variation on an
ordinary lambda list.  It differs from an ordinary lambda list in the
following ways:

@itemize @bullet
@item
There are no @code{&aux} parameters.
@item
All parameters introduced by the lambda list are lexical, and they are
represented by @hirundine{} registers, rather than by @commonlisp{}
symbols.
@item
@code{&optional} and @code{&key} parameters do not have an
@emph{initform}, but each one has a @emph{supplied-p} parameter.  An
@code{&optional} parameter is a proper list of two registers, the
first register represents the parameter itself, and the second one
represents a @emph{supplied-p} parameter.  A @code{&key} parameter is
a list of two elements.  The first element is a list of two elements,
a keyword and a @hirundine{} register for the parameter itself.  The
second element of the main list is a @hirundine{} register for the
@emph{supplied-p} parameter.
@end itemize

@noindent
Two more slots in an instruction of this type contain @hirundine{}
registers, one for the register holding the static-environment object
for this function, and the other one for the register holding the
dynamic-environment object upon function entry.

The outputs of an instruction of this type are the static-environment
register, the dynamic-environment register, and the lambda-list
parameter registers.

@subsection @code{nop-instruction}

@multitable {aaaa} {number of successors} {at least two}
@item @tab Number of inputs     @tab 0
@item @tab Number of outputs    @tab 0
@item @tab Number of successors @tab 1
@end multitable

An instruction of this type does nothing.

@subsection @code{assignment-instruction}

@multitable {aaaa} {number of successors} {at least two}
@item @tab Number of inputs     @tab 1
@item @tab Number of outputs    @tab 1
@item @tab Number of successors @tab 1
@end multitable

@noindent
The input of an instruction of this type is a register or a literal.
The register might be a single-value register or a multiple-value
register.  The output is a single-value register or a multiple-value
register.

The effect of executing an instruction of this type is that the object
in the input datum is copied to the output register.  If the input is
a single-value register or a literal and the output is a
multiple-value register, the output will contain a single object.  It
the input is a multiple-value register and the output is a
single-value register, the first object in the multiple-value register
is copied to the output register.

@subsection @code{enclose-instruction}

An instruction of this type has no inputs and one output.  The output
is a single-value register.  In addition, it has a slot containing an
instruction of type @code{parse-arguments-instruction}.  The result of
executing an instruction of this type is that the output register
contains a function object created as a closure from the
@code{parse-arguments-instruction}.  The closure does not yet contain
a static environment, which is later supplied by an instruction of
type @code{set-static-environment-instruction}.

@subsection @code{return-instruction}

An instruction of this type has one input and no outputs.  The input
is a @code{multiple-value-register}.  An instruction of this type has
no successors. The result of executing an instruction of this type is
that control is transferred to the caller of this function, with the
objects in the input register as the return values.

@subsection @code{if-instruction}

An instruction of this type has one input and no outputs.  The input
is a register or a literal.  An instruction of this type has two
successors.  The first successor is chosen if the object in the input
is something other than the symbol @code{nil}.  The second successor
is chosen if the object in the input is the symbol @code{nil}.

@subsection @code{make-cell-instruction}

An instruction of this type has one input and one output.  The input
is a register or a literal.  The output is a register.  An instruction
of this type has a single successor.  The result of executing an
instruction of this type is that an object of type @code{cell} (the
nature of which is not specified by this library) containing the
object in the input, will be contained in the output register.

@subsection @code{read-cell-instruction}

An instruction of this type has one input and one output.  The input
is a register containing a cell as created by the
@code{make-cell-instruction}.  The output is a register.  An
instruction of this type has a single successor.  The result of
executing an instruction of this type is that the output register will
contain the object contained in the cell.

@subsection @code{write-cell-instruction}

An instruction of this type has two inputs and no outputs.  The first
input is a register containing a cell as created by the
@code{make-cell-instruction}.  The second input is a register or a
literal.  An instruction of this type has a single successor.  The
result of executing and instruction of this type is that the cell will
contain the object in the second input.

@subsection @code{funcall-instruction}

An instruction of this type has at least two inputs and it has one
output.  The first input is a register that contains the function
object to be called.  The second input is a register that contains a
dynamic-environment object.  Each of the remaining inputs is either a
register or a literal, and these remaining inputs are the arguments to
be passed to the callee.  The output is a register that can be a
multiple-value register.  An instruction of this type has a single
successor.

The result of executing an instruction of this type is that the
function will be called with the arguments in the remaining inputs,
and with a dynamic environment that is the value of the second input.
The values returned by the function will be contained in the output
register.

@subsection @code{multiple-value-call-instruction}

An instruction of this type has at least two inputs and it has one
output.  The first input is a register that contains the function
object to be called.  The second input is a register that contains a
dynamic-environment object.  Each of the remaining inputs is either a
register or a literal, and these remaining inputs are the
multiple-value arguments to be passed to the callee.  The output is a
register that can be a multiple-value register.  An instruction of
this type has a single successor.

The result of executing an instruction of this type is that the
function will be called with the multiple-value arguments in the
remaining inputs, and with a dynamic environment that is the value of
the second input.  The values returned by the function will be
contained in the output register.

@subsection @code{global-function-reference-instruction}

An instruction of this type has no inputs and one output.  The output
is a single-value register.  It also has an additional slot containing
the name of a global function.  An instruction of this type has a
single successor.  The result of executing an instruction of this type
is that the function named by the contents of the additional slot is
stored in the output register.

@subsection @code{special-variable-binding-instruction}

An instruction of this type has two or three inputs and one output.
The first input is a register that contains a dynamic-environment
object.  The second input is a register or a literal with a name of a
special variable to bind.  If present, the third input is a register
or a literal.  The output is a register containing a
dynamic-environment object.

The result of executing an instruction of this type is to create a new
binding for the special variable named by the second input and to
store the augmented dynamic-environment object in the output
register.  If the third input is present, its value is used as the
value of the new binding.  If the third input is absent, the new
binding has no value, as can be the case with PROGV.

@subsection @code{special-variable-setq-instruction}

An instruction of this type has two inputs and no outputs.  It also
has an additional slot containing the name of the special variable to
assign to.  The first input is a register containing a
dynamic-environment object.  The second input is a register or a
literal containing the new value of the special variable.

@noindent
@center @image{return-instruction}

